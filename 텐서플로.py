# 텐서플로우
# 텐서 : 숫자, 다른 텐서를 포함할 수 있는 목록
# 배열과 비슷하다고 보면된다.

# 차원
# 1차원, 2차원, 3차원
# 용어 정리!
# 1) 벡터(Vector) : 한 차원만 가지는 텐서 -> 벡터
# [42, 35, 8, 64, 10] -> (5, ) -> 1차원
# [[1,2]
#  [3,4]] -> (2, 2) -> 2차원

# 2) 행렬(Matrix) : 2D 배열과 유사한 2D 텐서입니다.
# [[1,2,3]
#  [4,5,6]
#  [7,8,9]]    -> (3,3)

# 3) 고차원 텐서 : 3차원 이상의 모든 형태는 텐서이다.
# [[1,2,3]
#  [4,5,6]
#  [7,8,9]]
# [[10,11,12]
#  [13,14,15]
#  [16,17,18]]  -> (2, 3, 3) : 3 x 3 행렬이 2개

# 스칼라(Scalar) : 텐서에서는 0차원
# 42가 스칼라 값이다.

# 어떤 데이터를 텐서로 변환해야 한다면, 특징을 생성하는 방법을 결정해줘야 한다.
# 예) 단일 스칼라값을 입력 특정하는 프로그램 존재.
# 작업해야하는 입력은 훨씬 복잡하다.
# 이미지 -> 단일 숫자를 입력하는 것보다 더 복잡하고 어려움.

# 윈도윙
# - 알고리즘이 잘 돌고있는지 차트로 시각화 해주는 것
# - 알고리즘 자체가 잘 돌고 있는지 매 초마다 확인하는 방법
# 정규화
# - 신경망에서 공급하는 데이터를 부동소수점 또는 부동소수점으로 채워진 텐서 형태
# - 부동소수점 값의 크기가 서로 비슷해야한다.
# - 이상적인 값은 0 ~ 1 사이에 있는 것이다.

# 텐서플로우 모델 훈련
# 주어진 입력 세트로 올바른 출력을 생성하는 방법을 배우는 과정
# 모델을 통해서 교육데이터를 제공하고 가장 정확한 예측이 가능해질 때까지 조정하는 과정이 포함이 된다.

# 모델 -> 뉴런의 네트워크
# 숫자 배열로 표현이 된다.
# 가중치 + 편향으로 통칭되어져 있으며 네트워크의 [파라미터]

# 각 레이어의 가중치와 편향을 포함한 연속된 수학적 연산을 통해 반환이 된다.

# 출력이 곧 작업의 결과물입니다.
# 보통 가중치는 임의 값이 들어가고, 편향은 일반적으로 0으로 시작됩니다.
# 훈련 데이터의 [배치]를 모델에 적용시키고 모델 출력을 원하는 레이블과 비교를 합니다.
# [역전파] 알고리즘을 이용해서 시간이 지남에 따라 모델의 출력 결과가 원하는 값과 일치하도록
# 가중치와 편향을 조급씩 조정합니다.
# [에폭]단위로 진행이 되고, 인위적으로 멈추기 전까지 반복
# [에폭] : 반복

# 만약에 성능이 향상이 되지 않을 때!
# 멈춘다.
# 성능이 올라갔다고 하면 [정확한 예측]을 하기 시작하면
# 모델이 [수렴]했다고 합니다.
# 훈련중에 모델을 그래프를 통해서 확인합니다.
# 정확도, 학습 손실률
# 정확도가 100%에 가깝고, 손실률이 0%에 가까울 수록 좋은 학습

# 모델의 성능을 개선하기 위해서 모델의 아키텍처를 변경해주고, 훈련과정을 여러가지 값으로 
# 조정할 수 있는데, 이를 [하이퍼 파라미터]라고 합니다.
# [하이퍼 파라미터] : 훈련의 에폭수, 각 레이어의 뉴런 수

# 모델을 수렴하지 못한 경우!
# 과적합, 과소적합

# 과적합 : 훈련데이터를 너무 잘 배울 경우, 입력받을 때 레이블에 맞는 출력을 정확하게 예측할 수 있다.
# 하지만, 이전에 보지 못한 데이터까지 예측할 수 있는 일반화된 모델로서는 작동할 수 없다.
# [과적합 예방법] : 모델의 크기를 줄인다. -> 훈련 데이터를 그대로 다 표현하지 못하게 만든다.
# 일반화 기법을 사용해서 훈련에 적용하면 된다.
# 데이터를 나눠서 데이터 포인터를 생성한다.

# 과소적합 : 과적합과 반대의 개념.
# 훈련데이터를 적용하지 못함.

# 데이터를 나눈다. 그리고 많으면 많을수록 좋음

# 훈련, 검증, 테스트
# 훈련 데이터를 통해서 모델의 성능을 평가해야 한다.
# 모델의 성능에 대한 일부분만 보여줍니다.
# 모델의 훈련데이터를 처리한 값을 가능한 레이블에 가깝게 맞추는 법을 배웁니다. [과적합 모델]

# 과적합 모델 = 실재 성능에서 작동을 안 할 수도 있다.
# DataSet(데이터셋) : 훈련, 검증, 테스트로 나눈다.
# 입력한 데이터 분할 : 훈련 60%, 검증 20%, 테스트 20%

# 검증 : 손실을 계산하기 위한 용도. 주기적으로 모델에 제공한다.
# 훈련 과정에서 검증을 보지 못했기 때문에 검증을 통한 손실률은 모델 성능의 신뢰를 줍니다.
# 훈련 손실, 검증 손실(정확도 그외 다른 지표) 비교하고 해당 모델이 과적합이 되지 않게 만듭니다.

# 훈련 : 테스트 데이터를 실행해서 검증단계에서 확인했던 성능을 다시 확인하는 것
# 만약에 테스트 데이터로 검사를 했는데 성능이 나오지 않으면 훈련, 검증에서 과적합 모델이 만들어 졌다.
# 이것을 해결하기 위해서 새로운 아키텍처를 만들어야 되는 경우도 생깁니다.

# 모델 변환 -> 텐서플로우를 통해서 빌드하고 학습을 한다.
# 기본적으로 인터프리터를 사용한다.
# 텐서플로우 인터프리터 -> 테스크탑에서 모델을 실행하도록 설계
# 텐서플로우 라이트 : 소형 저전력 기기
# 텐서플로우 라이트 단계
# 1) 모델을 텐서플로우 라이트 형식으로 변환
# 2) 디스크 파일을 저장합니다. (텐서플로우 라이트 컨버터를 통해서)
# 3) 컨버터를 통해서 모델의 크기를 줄이고 성능을 저하시키지 않기 위해 최적화

# 모델의 변환이 끝났다면 모델을 배포를 준비
# 마이크로컨트롤러 텐서플로 라이트 C++ 라이브러리 사용해서 모델을 로드하고 예측을 수행합니다.
# 센서, 원시입력 데이터를 가져와서 훈련하는 데이터와 변환 코드를 작성해야 한다.
